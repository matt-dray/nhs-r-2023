---
title: "Base slaps!"
subtitle: "[matt-dray.github.io/nhs-r-2023](https://matt-dray.github.io/nhs-r-2023)"
author: "[Matt Dray](https://www.matt-dray.com), October 2023"
format:
  revealjs:
    theme: [default, nhs-r-2023.scss]
    hash-type: number
    margin: 0.2
    menu: false
    highlight-style: a11y
    code-line-numbers: false
title-slide-attributes:
  data-background-image: images/00-rgui-menu-dark.png
  data-background-position: top
  data-background-size: 100%
  data-notes: |
    * I'm Matt Dray, I help people in the public sector use R for reproducibility.
    * I'm here to tell you, or remind you, that good ol' vanilla base R is cool, actually.
    * Bonus points to folks who get the R reference in my slide theme.
include-in-header:
  - text: |
      <link rel = "shortcut icon" href = "images/09-quit.png" />
---

```{r}
#| label: setup
#| echo: false
knitr::opts_chunk$set(
  echo = TRUE,
  prompt = TRUE  # code-block lines begin with '>' and '+' prompt
)
```

## tl;dr {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

Base is great, don't forget about it!

## Bas(e)ically {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

. . .

Attached

```{r}
#| label: installed
(attached <- sessionInfo()$base |> sort())
```

. . .

Extent

```{r}
#| label: extent
extent <- installed.packages(priority = "base") |> row.names()
extent[extent != attached]
```

. . . 

Expanded universe 

```{r echo=TRUE}
#| label: expanded
installed.packages(priority = "recommended") |> row.names()
```

::: {.notes}
* What do we mean by 'base' R?
* It's actually several packages that are automatically installed (including one called 'base').
* Some are automatically attached when you start R. You can see this if you look at `sessionInfo()`.
* As an aside: note that you can assign and print if you wrap the whole thing in brackets.
* Some others are considered base, but not attached. These have priority 'base' when you look at the output of `installed.packages()`.
* There are also some non-base packages that have a special status: 'recommended'.

:::

## Stability {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

::: {.notes}
* Base packages have changed very little over time.
* Base code created 10 years ago has a pretty good chance of running today.
:::

## Dependency {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

::: {.notes}
* Using packages in your work can help make your life a lot easier.
* But you have to consider that dependencies can cause problems; packages and functions come and go.
* An understanding of base can get around some of this.
:::

## Modern (!) {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

* base pipe
* placeholder
* lambda
* string literals

::: {.notes}
* Stable and dependable, yes, but that doesn't mean it never advances.
* The pipe, developed in the {magrittr} package by Stefan Milton-Bache and popularised by the tidyverse, has come to base R.
* It's been followed by a placeholder to pass the LHS to the non-first argument on the RHS.
* A shorthand anonymous function, or 'lambda', has been introduced.
:::

## Pipe down {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

{magrittr}

```{r}
#| label: magrittr
library(magrittr)
chickwts %>% nrow()
```

```{r}
#| label: magrittr-ast
lobstr::ast(chickwts %>% nrow())
```

. . .

```{r}
#| label: magrittr-fn
`%>%`(chickwts, nrow)
```

. . .

Base

```{r}
#| label: bpipe
chickwts |> nrow()
```

```{r}
#| label: bpipe=ast
lobstr::ast(chickwts |> nrow())
```

## Hello, operator?  {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

## The infix is in {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

```{r}
#| label: infix-in
"R" %in% LETTERS
```

```{r}
#| label: infix-bespoke
`%ðŸ‘¯%` <- \(x, y) ifelse(x == y, TRUE, FALSE)
1 %ðŸ‘¯% 1
1 %ðŸ‘¯% 2
```

## plot {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

## Hidden gems {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

```{r eval=FALSE}
#| label: gems
tools::toTitleCase("care for a SAUSAGE ROLL?")
tools::file_ext("food/sausages.txt")
lengths()
Filter()
switch()
type.convert()
```

## {pixeltrix} [`r fontawesome::fa("github")`](https://github.com/matt-dray/pixeltrix) [`r fontawesome::fa("readme")`](https://www.rostrum.blog/index.html#category=pixeltrix) {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

`locator()`, `repeat`

![](images/pixeltrix.gif){fig-alt="Gif demonstration of the 'pixeltrix' package in RStudio. The click_pixels function is run. The plot window displays a grid of squares. The user clicks in some squares and they change to light grey. A second click turns them dark grey. The result is a blocky character made of pixels. The user hits the escape key and is returned a matrix representation of the character they made, including colour values as an attribute." width="100%" fig-align="left"}

::: {.notes}
* I want to show you three packages I've written for fun that include interesting base R functions.
* The first is the {pixeltrix}, a package for creating blocky pixel art, like you might see on retro videogames.
* It works thanks to `locator()`, a curious base function that lets you click a point on a plot and have its coordinates returned.
* {pixeltrix} contains a `repeat` loop, that asks the user to click on a plot with `locator()`; updates the plot given the click; and then re-asks the user to click until they break the `repeat` loop.
:::

## {r.oguelike} [`r fontawesome::fa("github")`](https://github.com/matt-dray/r.oguelike) [`r fontawesome::fa("readme")`](https://www.rostrum.blog/index.html#category=r.oguelike) {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

`readline()`, `matrix()`, `while`

![](images/r.oguelike.gif){fig-alt="Gif demonstration of the 'r.oguelike' package in the RStudio console. The 'start_game' function is run. The console clears and a text-based tile-based dungeon map appeears. Below is an inventory that includes health, money and food counters. Below is a prompt asking the user to type the W, A, S or D key and hit enter to move. The user does this and their player character moves around the dungeon space, collects an apple, battles an enemy and then eats the apple to restore health." width="100%" fig-align="left"}

::: {.notes}
* {r.oguelike} mimics an early text-based videogame. 
* It uses base R functions to procedurally build a tile-based dungeon, which is stored in a `matrix()` and queried with `which()` to identify the locations of characters. The player is `@` and the enemy is `E`. There's an inventory where gold can be stored, along with apples, `a`, that restore a health gauge.
* The user can move their character (represented by the `@` symbol) by typing into the interactive prompt, which is provided by the base function `readline()`. The enemy tracks the player.
:::

## {tamRgo} [`r fontawesome::fa("github")`](https://github.com/matt-dray/tamRgo) [`r fontawesome::fa("readme")`](https://www.rostrum.blog/posts/2022-11-13-tamrgo/) {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

`R_user_dir()`

![](images/tamRgo.gif){fig-alt="Gif demonstration of the 'tamRgo' package in the RStudio console. The 'tamRgo\ package is loaded, which tells the user that their pet, 'Kevin', is pleased to see them and also provides some prompts for interacting with the pet. The user uses the 'get_stats' function for a printout showing the pet's status, like its age and how hungry it is. The user uses the 'see_pet' function' and a blocky character is printed to the console, along with a blocky poop. The user runs the 'clean' function and reinspects the pet and stats to see that the 'dirty' status is now set to zero." width="100%" fig-align="left"}

::: {.notes}
* {tamRgo} simulates a cyber pet that lives on your computer and 'exists' between R sessions.
* Like a Tamagotchi in R, if you're the right age to know what a Tamagotchi is.
* How can data about your pet exist between sessions? The package makes use of the base R function `R_user_dir()`, which builds a path to a standardised location on the user's computer where data or cached items can be stored. In {tamRgo}, a 'blueprint' text file stores the pet's status. The blueprint is read at the start of the next R session and values related to time, such as the pet's age and hunger level, are updated given the difference between the current date and date of last interaction.
:::

## {background-image="images/00-rgui-menu-dark.png" background-position="top" background-size="100%"}

tl;dr: base is great, don't forget about it.

* Stability
* Dependency
* Hidden gems

[matt-dray.com](https://www.matt-dray.com)
